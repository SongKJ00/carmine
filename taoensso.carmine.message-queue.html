<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>taoensso.carmine.message-queue documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Carmine</span> <span class="project-version">3.2.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>taoensso</span></div></div></li><li class="depth-2"><a href="taoensso.carmine.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>carmine</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.benchmarks.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>benchmarks</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.commands.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>commands</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.connections.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connections</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.locks.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>locks</span></div></a></li><li class="depth-3 branch current"><a href="taoensso.carmine.message-queue.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>message-queue</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.protocol.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocol</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.ring.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ring</span></div></a></li><li class="depth-3"><a href="taoensso.carmine.tundra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tundra</span></div></a></li><li class="depth-4 branch"><a href="taoensso.carmine.tundra.carmine.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>carmine</span></div></a></li><li class="depth-4 branch"><a href="taoensso.carmine.tundra.disk.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>disk</span></div></a></li><li class="depth-4 branch"><a href="taoensso.carmine.tundra.faraday.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>faraday</span></div></a></li><li class="depth-4"><a href="taoensso.carmine.tundra.s3.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>s3</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-clear-queues"><div class="inner"><span>clear-queues</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-dequeue"><div class="inner"><span>dequeue</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-enqueue"><div class="inner"><span>enqueue</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-exp-backoff"><div class="inner"><span>exp-backoff</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-handle1"><div class="inner"><span>handle1</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-IWorker"><div class="inner"><span>IWorker</span></div></a></li><li class="depth-2 branch"><a href="taoensso.carmine.message-queue.html#var-start"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>start</span></div></a></li><li class="depth-2"><a href="taoensso.carmine.message-queue.html#var-stop"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stop</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-make-dequeue-worker"><div class="inner"><span>make-dequeue-worker</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-message-status"><div class="inner"><span>message-status</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-monitor-fn"><div class="inner"><span>monitor-fn</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queue-status"><div class="inner"><span>queue-status</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-worker"><div class="inner"><span>worker</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">taoensso.carmine.message-queue</h1><div class="doc"><pre class="plaintext">Carmine-backed Clojure message queue. All heavy lifting by Redis.
Message circle architecture used here is simple, reliable, and has
reasonable throughput but at best mediocre latency.

Redis keys:
  * carmine:mq:&lt;qname&gt;:messages     - hash, {mid mcontent}.
  * carmine:mq:&lt;qname&gt;:locks        - hash, {mid lock-expiry-time}.
  * carmine:mq:&lt;qname&gt;:backoffs     - hash, {mid backoff-expiry-time}.
  * carmine:mq:&lt;qname&gt;:nattempts    - hash, {mid attempt-count}.
  * carmine:mq:&lt;qname&gt;:mid-circle   - list, rotating list of mids (next on right).
  * carmine:mq:&lt;qname&gt;:done         - set, awaiting gc, requeue, etc.
  * carmine:mq:&lt;qname&gt;:requeue      - set, for `allow-requeue?` option.
  * carmine:mq:&lt;qname&gt;:eoq-backoff? - ttl flag, used for queue-wide
                                      (every-worker) polling backoff.
  * carmine:mq:&lt;qname&gt;:ndry-runs    - int, number of times worker(s) have
                                      burnt through queue w/o work to do.

Ref. <a href="http://antirez.com/post/250">http://antirez.com/post/250</a> for basic implementation details</pre></div><div class="public anchor" id="var-clear-queues"><h3>clear-queues</h3><div class="usage"><code>(clear-queues conn-opts &amp; qnames)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-dequeue"><h3>dequeue</h3><div class="usage"></div><div class="doc"><pre class="plaintext">IMPLEMENTATION DETAIL: Use `worker` instead.
Rotates queue's mid-circle and processes next mid. Returns:
  nil             - If msg GC'd, locked, or set to backoff.
  "eoq-backoff" - If circle uninitialized or end-of-circle marker reached.
  [&lt;mid&gt; &lt;mcontent&gt; &lt;attempt&gt;] - If message should be (re)handled now.</pre></div></div><div class="public anchor" id="var-enqueue"><h3>enqueue</h3><div class="usage"><code>(enqueue qname message)</code><code>(enqueue qname message {:keys [unique-message-id allow-requeue? initial-backoff-ms]})</code></div><div class="doc"><pre class="plaintext">Pushes given message (any Clojure datatype) to named queue and returns unique
message id or {:carmine.mq/error &lt;message-status&gt;}. Options:
  * unique-message-id  - Specify an explicit message id (e.g. message hash) to
                         perform a de-duplication check. If unspecified, a
                         unique id will be auto-generated.
  * allow-requeue?     - When true, allow buffered escrow-requeue for a
                         message in the :locked or :done-with-backoff state.
  * initial-backoff-ms - Initial backoff in millis.</pre></div></div><div class="public anchor" id="var-exp-backoff"><h3>exp-backoff</h3><div class="usage"><code>(exp-backoff n-attempt)</code><code>(exp-backoff n-attempt {:keys [min max factor], :or {factor 1000}})</code></div><div class="doc"><pre class="plaintext">Returns binary exponential backoff value for n&lt;=36.
</pre></div></div><div class="public anchor" id="var-handle1"><h3>handle1</h3><div class="usage"><code>(handle1 conn-opts qname handler [mid mcontent attempt :as poll-reply])</code></div><div class="doc"><pre class="plaintext">Implementation detail!
</pre></div></div><div class="public anchor" id="var-IWorker"><h3>IWorker</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-start"><h3>start</h3><div class="usage"><code>(start this)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-stop"><h3>stop</h3><div class="usage"><code>(stop this)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div></div><div class="public anchor" id="var-make-dequeue-worker"><h3>make-dequeue-worker</h3><div class="usage"><code>(make-dequeue-worker pool spec &amp; {:keys [handler-fn handler-ttl-msecs backoff-msecs throttle-msecs auto-start?]})</code></div><div class="doc"><pre class="plaintext">DEPRECATED: Use `worker` instead.
</pre></div></div><div class="public anchor" id="var-message-status"><h3>message-status</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Returns current message status, e/o:
  :queued               - Awaiting handler.
  :queued-with-backoff  - Awaiting rehandling.
  :locked               - Currently with handler.
  :locked-with-requeue  - Currently with handler, will requeue on success.
  :done-awaiting-gc     - Finished handling, awaiting GC.
  :done-with-backoff    - Finished handling, awaiting dedupe timeout.
nil                   - Already GC'd or invalid message id.</pre></div></div><div class="public anchor" id="var-monitor-fn"><h3>monitor-fn</h3><div class="usage"><code>(monitor-fn qname max-circle-size warn-backoff-ms)</code></div><div class="doc"><pre class="plaintext">Returns a worker monitor fn that warns when queue's mid-circle exceeds
the prescribed size. A backoff timeout can be provided to rate-limit this
warning.</pre></div></div><div class="public anchor" id="var-queue-status"><h3>queue-status</h3><div class="usage"><code>(queue-status conn-opts qname)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-worker"><h3>worker</h3><div class="usage"><code>(worker conn-opts qname &amp; [{:keys [handler monitor lock-ms eoq-backoff-ms nthreads throttle-ms auto-start], :as opts, :or {handler (fn [args] (timbre/infof "%s" args) {:status :success}), monitor (monitor-fn qname 1000 (enc/ms :hours 6)), lock-ms (enc/ms :hours 1), nthreads 1, throttle-ms 200, eoq-backoff-ms exp-backoff, auto-start true}}])</code></div><div class="doc"><pre class="plaintext">Returns a threaded worker to poll for and handle messages `enqueue`'d to
named queue. Options:
 :handler        - (fn [{:keys [qname mid message attempt]}]) that throws an ex
                   or returns {:status     &lt;#{:success :error :retry}&gt;
                               :throwable  &lt;Throwable&gt;
                               :backoff-ms &lt;retry-or-dedupe-backoff-ms}.
 :monitor        - (fn [{:keys [mid-circle-size ndry-runs poll-reply]}])
                   called on each worker loop iteration. Useful for queue
                   monitoring/logging. See also `monitor-fn`.
 :lock-ms        - Max time handler may keep a message before handler
                   considered fatally stalled and message re-queued. Must be
                   sufficiently high to prevent double handling.
 :eoq-backoff-ms - Thread sleep period each time end of queue is reached.
                   Can be a (fn [ndry-runs]) -&gt; ms (n&lt;=5) will be used.
                   Sleep synchronized for all queue workers.
 :nthreads       - Number of synchronized worker threads to use.
 :throttle-ms    - Thread sleep period between each poll.</pre></div></div></div></body></html>